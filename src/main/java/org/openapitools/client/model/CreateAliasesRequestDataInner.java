/*
 * Vault HTTP API
 * The VGS Vault HTTP API is used for storing, retrieving, and managing sensitive data (aka Tokenization) within a VGS Vault.  The VGS API is organized around REST. Our API is built with a predictable resource-oriented structure, uses JSON-encoded requests and responses, follows standard HTTP verbs/responses, and uses industry standard authentication.  ## What is VGS  Storing sensitive data on your company’s infrastructure often comes with a heavy compliance burden. For instance, storing payments data yourself greatly increases the amount of work needed to become PCI compliant. It also increases your security risk in general. To combat this, companies will minimize the amount of sensitive information they have to handle or store.  VGS provides multiple methods for minimizing the sensitive information that needs to be stored which allows customers to secure any type of data for any use-case.  **Tokenization** is a method that focuses on securing the storage of data. This is the quickest way to get started and is free. [Get started with Tokenization](https://www.verygoodsecurity.com/docs/tokenization/getting-started).  **Zero Data** is a unique method invented by VGS in 2016 that securely stores data like Tokenization, however it also removes the customer’s environment from PCI scope completely providing maximum security, and minimum compliance scope. [Get started with Zero Data](https://www.verygoodsecurity.com/docs/getting-started/before-you-start).  Additionally, for scenarios where neither technology is a complete solution, for instance with legacy systems, VGS provides a compliance product which guarantees customers are able to meet their compliance needs no matter what may happen. [Get started with Control](https://www.verygoodsecurity.com/docs/control).  ## Learn about Tokenization  - [Create an Account for Free Tokenization](https://dashboard.verygoodsecurity.com/tokenization) - [Try a Tokenization Demo](https://www.verygoodsecurity.com/docs/tokenization/getting-started) - [Install a Tokenization SDK](https://www.verygoodsecurity.com/docs/tokenization/client-libraries)  ### Authentication  This API uses `Basic` authentication and is implemented using industry best practices to ensure the security of the connection. Read more about [Identity and Access Management at VGS](https://www.verygoodsecurity.com/docs/vault/the-platform/iam)  Credentials to access the API can be generated on the [dashboard](https://dashboard.verygoodsecurity.com) by going to the Settings section of the vault of your choosing.  [Docs » Guides » Access credentials](https://www.verygoodsecurity.com/docs/settings/access-credentials)  ## Resource Limits  ### Data Limits  This API allows storing data up to 32MB in size.  ### Rate Limiting  The API allows up to 3,000 requests per minute. Requests are associated with the vault, regardless of the access credentials used to authenticate the request.  Your current rate limit is included as HTTP headers in every API response:  | Header Name             | Description                                              | |-------------------------|----------------------------------------------------------| | `x-ratelimit-remaining` | The number of requests remaining in the 1-minute window. |  If you exceed the rate limit, the API will reject the request with HTTP [429 Too Many Requests](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/429).  ### Errors  The API uses standard HTTP status codes to indicate whether the request succeeded or not.  In case of failure, the response body will be JSON in a predefined format. For example, trying to create too many aliases at once results in the following response:  ```json {     \"errors\": [         {             \"status\": 400,             \"title\": \"Bad request\",             \"detail\": \"Too many values (limit: 20)\",             \"href\": \"https://api.sandbox.verygoodvault.com/aliases\"         }     ] } ``` 
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: support@verygoodsecurity.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import java.util.Arrays;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import io.swagger.annotations.ApiModel;
import io.swagger.annotations.ApiModelProperty;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
import org.openapitools.client.model.AliasFormat;
import org.openapitools.client.model.CreateAliasesRequestNew;
import org.openapitools.client.model.CreateAliasesRequestReference;

import javax.ws.rs.core.GenericType;

import java.io.IOException;
import java.lang.reflect.Type;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashSet;
import java.util.HashMap;
import java.util.Map;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapter;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.JsonPrimitive;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonSerializationContext;
import com.google.gson.JsonSerializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;

import org.openapitools.client.JSON;

@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2022-10-11T08:06:56.559215+01:00[Africa/Lagos]")
public class CreateAliasesRequestDataInner extends AbstractOpenApiSchema {
    private static final Logger log = Logger.getLogger(CreateAliasesRequestDataInner.class.getName());

    public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
        @SuppressWarnings("unchecked")
        @Override
        public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
            if (!CreateAliasesRequestDataInner.class.isAssignableFrom(type.getRawType())) {
                return null; // this class only serializes 'CreateAliasesRequestDataInner' and its subtypes
            }
            final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
            final TypeAdapter<CreateAliasesRequestNew> adapterCreateAliasesRequestNew = gson.getDelegateAdapter(this, TypeToken.get(CreateAliasesRequestNew.class));
            final TypeAdapter<CreateAliasesRequestReference> adapterCreateAliasesRequestReference = gson.getDelegateAdapter(this, TypeToken.get(CreateAliasesRequestReference.class));

            return (TypeAdapter<T>) new TypeAdapter<CreateAliasesRequestDataInner>() {
                @Override
                public void write(JsonWriter out, CreateAliasesRequestDataInner value) throws IOException {
                    if (value == null || value.getActualInstance() == null) {
                        elementAdapter.write(out, null);
                        return;
                    }

                    // check if the actual instance is of the type `CreateAliasesRequestNew`
                    if (value.getActualInstance() instanceof CreateAliasesRequestNew) {
                        JsonObject obj = adapterCreateAliasesRequestNew.toJsonTree((CreateAliasesRequestNew)value.getActualInstance()).getAsJsonObject();
                        elementAdapter.write(out, obj);
                        return;
                    }

                    // check if the actual instance is of the type `CreateAliasesRequestReference`
                    if (value.getActualInstance() instanceof CreateAliasesRequestReference) {
                        JsonObject obj = adapterCreateAliasesRequestReference.toJsonTree((CreateAliasesRequestReference)value.getActualInstance()).getAsJsonObject();
                        elementAdapter.write(out, obj);
                        return;
                    }

                    throw new IOException("Failed to serialize as the type doesn't match oneOf schemas: CreateAliasesRequestNew, CreateAliasesRequestReference");
                }

                @Override
                public CreateAliasesRequestDataInner read(JsonReader in) throws IOException {
                    Object deserialized = null;
                    JsonObject jsonObject = elementAdapter.read(in).getAsJsonObject();

                    int match = 0;
                    ArrayList<String> errorMessages = new ArrayList<>();
                    TypeAdapter actualAdapter = elementAdapter;

                    // deserialize CreateAliasesRequestNew
                    try {
                        // validate the JSON object to see if any exception is thrown
                        CreateAliasesRequestNew.validateJsonObject(jsonObject);
                        actualAdapter = adapterCreateAliasesRequestNew;
                        match++;
                        log.log(Level.FINER, "Input data matches schema 'CreateAliasesRequestNew'");
                    } catch (Exception e) {
                        // deserialization failed, continue
                        errorMessages.add(String.format("Deserialization for CreateAliasesRequestNew failed with `%s`.", e.getMessage()));
                        log.log(Level.FINER, "Input data does not match schema 'CreateAliasesRequestNew'", e);
                    }

                    // deserialize CreateAliasesRequestReference
                    try {
                        // validate the JSON object to see if any exception is thrown
                        CreateAliasesRequestReference.validateJsonObject(jsonObject);
                        actualAdapter = adapterCreateAliasesRequestReference;
                        match++;
                        log.log(Level.FINER, "Input data matches schema 'CreateAliasesRequestReference'");
                    } catch (Exception e) {
                        // deserialization failed, continue
                        errorMessages.add(String.format("Deserialization for CreateAliasesRequestReference failed with `%s`.", e.getMessage()));
                        log.log(Level.FINER, "Input data does not match schema 'CreateAliasesRequestReference'", e);
                    }

                    if (match == 1) {
                        CreateAliasesRequestDataInner ret = new CreateAliasesRequestDataInner();
                        ret.setActualInstance(actualAdapter.fromJsonTree(jsonObject));
                        return ret;
                    }

                    throw new IOException(String.format("Failed deserialization for CreateAliasesRequestDataInner: %d classes match result, expected 1. Detailed failure message for oneOf schemas: %s. JSON: %s", match, errorMessages, jsonObject.toString()));
                }
            }.nullSafe();
        }
    }

    // store a list of schema names defined in oneOf
    public static final Map<String, GenericType> schemas = new HashMap<String, GenericType>();

    public CreateAliasesRequestDataInner() {
        super("oneOf", Boolean.FALSE);
    }

    public CreateAliasesRequestDataInner(CreateAliasesRequestNew o) {
        super("oneOf", Boolean.FALSE);
        setActualInstance(o);
    }

    public CreateAliasesRequestDataInner(CreateAliasesRequestReference o) {
        super("oneOf", Boolean.FALSE);
        setActualInstance(o);
    }

    static {
        schemas.put("CreateAliasesRequestNew", new GenericType<CreateAliasesRequestNew>() {
        });
        schemas.put("CreateAliasesRequestReference", new GenericType<CreateAliasesRequestReference>() {
        });
    }

    @Override
    public Map<String, GenericType> getSchemas() {
        return CreateAliasesRequestDataInner.schemas;
    }

    /**
     * Set the instance that matches the oneOf child schema, check
     * the instance parameter is valid against the oneOf child schemas:
     * CreateAliasesRequestNew, CreateAliasesRequestReference
     *
     * It could be an instance of the 'oneOf' schemas.
     * The oneOf child schemas may themselves be a composed schema (allOf, anyOf, oneOf).
     */
    @Override
    public void setActualInstance(Object instance) {
        if (instance instanceof CreateAliasesRequestNew) {
            super.setActualInstance(instance);
            return;
        }

        if (instance instanceof CreateAliasesRequestReference) {
            super.setActualInstance(instance);
            return;
        }

        throw new RuntimeException("Invalid instance type. Must be CreateAliasesRequestNew, CreateAliasesRequestReference");
    }

    /**
     * Get the actual instance, which can be the following:
     * CreateAliasesRequestNew, CreateAliasesRequestReference
     *
     * @return The actual instance (CreateAliasesRequestNew, CreateAliasesRequestReference)
     */
    @Override
    public Object getActualInstance() {
        return super.getActualInstance();
    }

    /**
     * Get the actual instance of `CreateAliasesRequestNew`. If the actual instance is not `CreateAliasesRequestNew`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of `CreateAliasesRequestNew`
     * @throws ClassCastException if the instance is not `CreateAliasesRequestNew`
     */
    public CreateAliasesRequestNew getCreateAliasesRequestNew() throws ClassCastException {
        return (CreateAliasesRequestNew)super.getActualInstance();
    }

    /**
     * Get the actual instance of `CreateAliasesRequestReference`. If the actual instance is not `CreateAliasesRequestReference`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of `CreateAliasesRequestReference`
     * @throws ClassCastException if the instance is not `CreateAliasesRequestReference`
     */
    public CreateAliasesRequestReference getCreateAliasesRequestReference() throws ClassCastException {
        return (CreateAliasesRequestReference)super.getActualInstance();
    }


 /**
  * Validates the JSON Object and throws an exception if issues found
  *
  * @param jsonObj JSON Object
  * @throws IOException if the JSON Object is invalid with respect to CreateAliasesRequestDataInner
  */
  public static void validateJsonObject(JsonObject jsonObj) throws IOException {
    // validate oneOf schemas one by one
    int validCount = 0;
    ArrayList<String> errorMessages = new ArrayList<>();
    // validate the json string with CreateAliasesRequestNew
    try {
      CreateAliasesRequestNew.validateJsonObject(jsonObj);
      validCount++;
    } catch (Exception e) {
      errorMessages.add(String.format("Deserialization for CreateAliasesRequestNew failed with `%s`.", e.getMessage()));
      // continue to the next one
    }
    // validate the json string with CreateAliasesRequestReference
    try {
      CreateAliasesRequestReference.validateJsonObject(jsonObj);
      validCount++;
    } catch (Exception e) {
      errorMessages.add(String.format("Deserialization for CreateAliasesRequestReference failed with `%s`.", e.getMessage()));
      // continue to the next one
    }
    if (validCount != 1) {
      throw new IOException(String.format("The JSON string is invalid for CreateAliasesRequestDataInner with oneOf schemas: CreateAliasesRequestNew, CreateAliasesRequestReference. %d class(es) match the result, expected 1. Detailed failure message for oneOf schemas: %s. JSON: %s", validCount, errorMessages, jsonObj.toString()));
    }
  }

 /**
  * Create an instance of CreateAliasesRequestDataInner given an JSON string
  *
  * @param jsonString JSON string
  * @return An instance of CreateAliasesRequestDataInner
  * @throws IOException if the JSON string is invalid with respect to CreateAliasesRequestDataInner
  */
  public static CreateAliasesRequestDataInner fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, CreateAliasesRequestDataInner.class);
  }

 /**
  * Convert an instance of CreateAliasesRequestDataInner to an JSON string
  *
  * @return JSON string
  */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

